{"ast":null,"code":"var _require = require('./helpers'),\n    wikidataTimeToISOString = _require.wikidataTimeToISOString,\n    wikidataTimeToEpochTime = _require.wikidataTimeToEpochTime,\n    wikidataTimeToSimpleDay = _require.wikidataTimeToSimpleDay;\n\nvar simple = function simple(datavalue) {\n  return datavalue.value;\n};\n\nvar monolingualtext = function monolingualtext(datavalue, options) {\n  return options.keepRichValues ? datavalue.value : datavalue.value.text;\n};\n\nvar entity = function entity(datavalue, options) {\n  return prefixedId(datavalue, options.entityPrefix);\n};\n\nvar entityLetter = {\n  item: 'Q',\n  lexeme: 'L',\n  property: 'P'\n};\n\nvar prefixedId = function prefixedId(datavalue, prefix) {\n  var value = datavalue.value;\n  var id = value.id || entityLetter[value['entity-type']] + value['numeric-id'];\n  return typeof prefix === 'string' ? \"\".concat(prefix, \":\").concat(id) : id;\n};\n\nvar quantity = function quantity(datavalue, options) {\n  var value = datavalue.value;\n  var amount = parseFloat(value.amount);\n\n  if (options.keepRichValues) {\n    var _amount = parseFloat(value.amount);\n\n    var unit = value.unit.replace('http://www.wikidata.org/entity/', '');\n    var upperBound = parseFloat(value.upperBound);\n    var lowerBound = parseFloat(value.lowerBound);\n    return {\n      amount: _amount,\n      unit: unit,\n      upperBound: upperBound,\n      lowerBound: lowerBound\n    };\n  } else {\n    return amount;\n  }\n};\n\nvar coordinate = function coordinate(datavalue) {\n  return [datavalue.value.latitude, datavalue.value.longitude];\n};\n\nvar time = function time(datavalue, options) {\n  return getTimeConverter(options.timeConverter)(datavalue.value);\n};\n\nvar getTimeConverter = function getTimeConverter() {\n  var key = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'iso';\n  return timeConverters[key];\n}; // Each time converter should be able to accept 2 keys of arguments:\n// - either datavalue.value objects (prefered as it gives access to the precision)\n// - or the time string (datavalue.value.time)\n\n\nvar timeConverters = {\n  iso: wikidataTimeToISOString,\n  epoch: wikidataTimeToEpochTime,\n  'simple-day': wikidataTimeToSimpleDay,\n  none: function none(wikidataTime) {\n    return wikidataTime.time || wikidataTime;\n  }\n};\nvar parsers = {\n  string: simple,\n  commonsMedia: simple,\n  url: simple,\n  'external-id': simple,\n  math: simple,\n  monolingualtext: monolingualtext,\n  'wikibase-item': entity,\n  'wikibase-lexeme': entity,\n  'wikibase-property': entity,\n  time: time,\n  quantity: quantity,\n  'globe-coordinate': coordinate,\n  'geo-shape': simple,\n  'tabular-data': simple,\n  'musical-notation': simple\n};\nmodule.exports = {\n  parsers: parsers,\n  parse: function parse(datatype, datavalue, options, claimId) {\n    if (!datatype) {\n      // Ex: https://www.wikidata.org/w/index.php?title=Q2105758&oldid=630350590\n      console.error('invalid claim', claimId);\n      return null;\n    }\n\n    try {\n      return parsers[datatype](datavalue, options);\n    } catch (err) {\n      if (err.message === 'parsers[datatype] is not a function') {\n        err.message = \"\".concat(datatype, \" claim parser isn't implemented\\n        Claim id: \").concat(claimId, \"\\n        Please report to https://github.com/maxlath/wikidata-sdk/issues\");\n      }\n\n      throw err;\n    }\n  }\n};","map":null,"metadata":{},"sourceType":"script"}