{"ast":null,"code":"var _slicedToArray = require(\"/Users/tallrye/React/swe573/wlearn-react/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _require = require('./parse_claim'),\n    parseClaim = _require.parse;\n\nvar _require2 = require('../utils/utils'),\n    uniq = _require2.uniq; // Expects an entity 'claims' object\n// Ex: entity.claims\n\n\nvar simplifyClaims = function simplifyClaims(claims) {\n  for (var _len = arguments.length, options = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    options[_key - 1] = arguments[_key];\n  }\n\n  var _parseOptions = parseOptions(options),\n      propertyPrefix = _parseOptions.propertyPrefix;\n\n  var simpleClaims = {};\n\n  for (var id in claims) {\n    var propClaims = claims[id];\n\n    if (propertyPrefix) {\n      id = propertyPrefix + ':' + id;\n    }\n\n    simpleClaims[id] = simplifyPropertyClaims.apply(void 0, [propClaims].concat(options));\n  }\n\n  return simpleClaims;\n}; // Expects the 'claims' array of a particular property\n// Ex: entity.claims.P369\n\n\nvar simplifyPropertyClaims = function simplifyPropertyClaims(propClaims) {\n  for (var _len2 = arguments.length, options = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    options[_key2 - 1] = arguments[_key2];\n  }\n\n  // Avoid to throw on empty inputs to allow to simplify claims array\n  // without having to know if the entity as claims for this property\n  // Ex: simplifyPropertyClaims(entity.claims.P124211616)\n  if (propClaims == null || propClaims.length === 0) return [];\n\n  var _parseOptions2 = parseOptions(options),\n      keepNonTruthy = _parseOptions2.keepNonTruthy,\n      areSubSnaks = _parseOptions2.areSubSnaks;\n\n  if (!(keepNonTruthy || areSubSnaks)) {\n    propClaims = truthyPropertyClaims(propClaims);\n  }\n\n  propClaims = propClaims.map(function (claim) {\n    return simplifyClaim.apply(void 0, [claim].concat(options));\n  }) // Filter-out novalue and somevalue claims,\n  // unless a novalueValue or a somevalueValue is passed in options\n  .filter(defined); // Deduplicate values unless we return a rich value object\n\n  if (propClaims[0] && typeof propClaims[0] !== 'object') {\n    return uniq(propClaims);\n  } else {\n    return propClaims;\n  }\n};\n\nvar aggregatePerRank = function aggregatePerRank(aggregate, claim) {\n  var rank = claim.rank;\n  aggregate[rank] || (aggregate[rank] = []);\n  aggregate[rank].push(claim);\n  return aggregate;\n};\n\nvar truthyPropertyClaims = function truthyPropertyClaims(propClaims) {\n  var aggregate = propClaims.reduce(aggregatePerRank, {}); // on truthyness: https://www.mediawiki.org/wiki/Wikibase/Indexing/RDF_Dump_Format#Truthy_statements\n\n  return aggregate.preferred || aggregate.normal || [];\n};\n\nvar truthyClaims = function truthyClaims(claims) {\n  var truthClaimsOnly = {};\n  Object.keys(claims).forEach(function (property) {\n    truthClaimsOnly[property] = truthyPropertyClaims(claims[property]);\n  });\n  return truthClaimsOnly;\n}; // Considers null as defined\n\n\nvar defined = function defined(obj) {\n  return obj !== undefined;\n}; // Expects a single claim object\n// Ex: entity.claims.P369[0]\n\n\nvar simplifyClaim = function simplifyClaim(claim) {\n  for (var _len3 = arguments.length, options = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    options[_key3 - 1] = arguments[_key3];\n  }\n\n  options = parseOptions(options);\n\n  var _parseKeepOptions = parseKeepOptions(options),\n      keepQualifiers = _parseKeepOptions.keepQualifiers,\n      keepReferences = _parseKeepOptions.keepReferences,\n      keepIds = _parseKeepOptions.keepIds,\n      keepHashes = _parseKeepOptions.keepHashes,\n      keepTypes = _parseKeepOptions.keepTypes,\n      keepSnaktypes = _parseKeepOptions.keepSnaktypes,\n      keepRanks = _parseKeepOptions.keepRanks; // tries to replace wikidata deep claim object by a simple value\n  // e.g. a string, an entity Qid or an epoch time number\n\n\n  var mainsnak = claim.mainsnak,\n      rank = claim.rank;\n  var value, datatype, datavalue, snaktype, isQualifierSnak, isReferenceSnak;\n\n  if (mainsnak) {\n    datatype = mainsnak.datatype;\n    datavalue = mainsnak.datavalue;\n    snaktype = mainsnak.snaktype;\n  } else {\n    // Qualifiers have no mainsnak, and define datatype, datavalue on claim\n    datavalue = claim.datavalue;\n    datatype = claim.datatype;\n    snaktype = claim.snaktype; // Duck typing the sub-snak type\n\n    if (claim.hash) isQualifierSnak = true;else isReferenceSnak = true;\n  }\n\n  if (datavalue) {\n    value = parseClaim(datatype, datavalue, options, claim.id);\n  } else {\n    if (snaktype === 'somevalue') value = options.somevalueValue;else if (snaktype === 'novalue') value = options.novalueValue;else throw new Error('no datavalue or special snaktype found');\n  } // Qualifiers should not attempt to keep sub-qualifiers or references\n\n\n  if (isQualifierSnak) {\n    if (!(keepHashes || keepTypes)) return value;\n    var _richValue = {\n      value: value\n    };\n    if (keepHashes) _richValue.hash = claim.hash;\n    if (keepTypes) _richValue.type = datatype;\n    return _richValue;\n  }\n\n  if (isReferenceSnak) {\n    if (!keepTypes) return value;\n    return {\n      type: datatype,\n      value: value\n    };\n  } // No need to test keepHashes as it has no effect if neither\n  // keepQualifiers or keepReferences is true\n\n\n  if (!(keepQualifiers || keepReferences || keepIds || keepTypes || keepSnaktypes || keepRanks)) {\n    return value;\n  } // When keeping qualifiers or references, the value becomes an object\n  // instead of a direct value\n\n\n  var richValue = {\n    value: value\n  };\n  if (keepTypes) richValue.type = datatype;\n  if (keepSnaktypes) richValue.snaktype = snaktype;\n  if (keepRanks) richValue.rank = rank;\n  var subSnaksOptions = getSubSnakOptions(options);\n  subSnaksOptions.keepHashes = keepHashes;\n\n  if (keepQualifiers) {\n    richValue.qualifiers = simplifyClaims(claim.qualifiers, subSnaksOptions);\n  }\n\n  if (keepReferences) {\n    claim.references = claim.references || [];\n    richValue.references = claim.references.map(function (refRecord) {\n      var snaks = simplifyClaims(refRecord.snaks, subSnaksOptions);\n      if (keepHashes) return {\n        snaks: snaks,\n        hash: refRecord.hash\n      };else return snaks;\n    });\n  }\n\n  if (keepIds) richValue.id = claim.id;\n  return richValue;\n};\n\nvar parseOptions = function parseOptions(options) {\n  if (options == null) return {};\n  if (options[0] && typeof options[0] === 'object') return options[0]; // Legacy interface\n\n  var _options = _slicedToArray(options, 3),\n      entityPrefix = _options[0],\n      propertyPrefix = _options[1],\n      keepQualifiers = _options[2];\n\n  return {\n    entityPrefix: entityPrefix,\n    propertyPrefix: propertyPrefix,\n    keepQualifiers: keepQualifiers\n  };\n};\n\nvar simplifyQualifiers = function simplifyQualifiers(claims, options) {\n  return simplifyClaims(claims, getSubSnakOptions(options));\n};\n\nvar simplifyPropertyQualifiers = function simplifyPropertyQualifiers(propClaims, options) {\n  return simplifyPropertyClaims(propClaims, getSubSnakOptions(options));\n}; // Using a new object so that the original options object isn't modified\n\n\nvar getSubSnakOptions = function getSubSnakOptions(options) {\n  return Object.assign({}, options, {\n    areSubSnaks: true\n  });\n};\n\nvar keepOptions = ['keepQualifiers', 'keepReferences', 'keepIds', 'keepHashes', 'keepTypes', 'keepSnaktypes', 'keepRanks'];\n\nvar parseKeepOptions = function parseKeepOptions(options) {\n  if (options.keepAll) {\n    keepOptions.forEach(function (optionName) {\n      if (options[optionName] == null) options[optionName] = true;\n    });\n  }\n\n  return options;\n};\n\nmodule.exports = {\n  simplifyClaims: simplifyClaims,\n  simplifyPropertyClaims: simplifyPropertyClaims,\n  simplifyClaim: simplifyClaim,\n  truthyClaims: truthyClaims,\n  truthyPropertyClaims: truthyPropertyClaims,\n  simplifyQualifiers: simplifyQualifiers,\n  simplifyPropertyQualifiers: simplifyPropertyQualifiers,\n  simplifyQualifier: simplifyClaim\n};","map":null,"metadata":{},"sourceType":"script"}